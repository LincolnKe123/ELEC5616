\title{\vspace{-5ex} \large Part 2 :: Protecting the Castle \\ \large (Commanding the Legion)\vspace{-2ex}}
\author{\large Dean Pisani 311210775 \\ \large Kristy Hughes 310186293\vspace{-2ex}}
\date{}

\documentclass[9pt,a4paper]{article}
\usepackage[top=1in,bottom=1in, left=1in, right=1in]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{sectsty}

\sectionfont{\fontsize{11}{9}\selectfont}

% Set up python syntax highlighting
\definecolor{Code}{rgb}{0,0,0}
\definecolor{Decorators}{rgb}{0.5,0.5,0.5}
\definecolor{Numbers}{rgb}{0.5,0,0}
\definecolor{MatchingBrackets}{rgb}{0.25,0.5,0.5}
\definecolor{Keywords}{rgb}{0,0,1}
\definecolor{self}{rgb}{0,0,0}
\definecolor{Strings}{rgb}{0,0.63,0}
\definecolor{Comments}{rgb}{0,0.63,0.2}
\definecolor{Backquotes}{rgb}{0,0,0}
\definecolor{Classname}{rgb}{0,0,0}
\definecolor{FunctionName}{rgb}{0,0,0}
\definecolor{Operators}{rgb}{0,0,0}
\definecolor{Background}{rgb}{0.98,0.98,0.98}

\lstnewenvironment{python}[1][]{
\lstset{
numbers=left,
numberstyle=\footnotesize,
numbersep=1em,
xleftmargin=1em,
framextopmargin=2em,
framexbottommargin=2em,
showspaces=false,
showtabs=false,
showstringspaces=false,
frame=l,
tabsize=4,
% Basic
basicstyle=\ttfamily\small\setstretch{1},
backgroundcolor=\color{Background},
language=Python,
% Comments
commentstyle=\color{Comments}\slshape,
% Strings
stringstyle=\color{Strings},
morecomment=[s][\color{Strings}]{"""}{"""},
morecomment=[s][\color{Strings}]{'''}{'''},
% keywords
morekeywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,True,False,None,access,as,,del,except,exec,finally,global,import,lambda,pass,print,raise,try,assert},
keywordstyle={\color{Keywords}\bfseries},
% additional keywords
morekeywords={[2]@invariant},
keywordstyle={[2]\color{Decorators}\slshape},
emph={self},
emphstyle={\color{self}\slshape},
%
}}{}

\begin{document}
\maketitle
\small
\setlength{\parindent}{0pt}

\section{Introduction to RSA}

\section{Authentication}
\emph{How do you ensure the only one who can send updates to SkyNet is the botnet master?}

Updates made to pastebot.net need to be signed by the master for them to be considered valid. We used asymmetric encryption using the RSA digital signature protocol with appendix according to PKCS\#1 PSS, which counters vulnerabilities introduced by using RSA encryption without proper cryptographic padding. The RSA keypair generated by the master is used for this signature, since the signatures make use of the master's private key. A bot then uses the master's public key which is made available to verify the signature. Only valid signatures are accepted by the bots, and since signatures can only be made with the private key the master holds, this ensures only the master can send updates to the bots. If an attacker were to attempt to create their own updates, or modify one in transit, then the signature will not be valid, since it has to be created using the private key combined with the original message.

\section{Confidentiality}
\emph{How do you protect the valuable information to ensure it can only  be read by the botnet master?}

When bot's upload files to pastebot.net, they are encrypted using RSA. This takes the botnet master's public key. Thus, only somone in possession of the botnet master's RSA private key can decrypt these valuable documents. With an asymmetric cipher like RSA, we can ensure that any valuable data cannot be read by anyone - including bots - since they do not know the master's private key.

Here is the encryption code that any bot can perform using the master's public key
\begin{center}
\vspace{-2ex}
\begin{python}
def encrypt_for_master(data):
    # TODO: what does this line of code do?
    h=SHA.new(data)
    # Read in the master'spublic key
    key = RSA.importKey(open(os.path.join("pastebot.net", "master_rsa.pub")).read())
    # Create a cypher object with the key
    cipher = PKCS1_v1_5.new(key)
    # Encrypt the valuable data
    ciphertext = cipher.encrypt(data+h.digest())
    # Return encrypted data
    return ciphertext
\end{python}
\end{center}

\begin{center}
\vspace{-2ex}
\begin{python}
def decrypt_valuables(f):
    # Read in the private key
    key = RSA.importKey(open('TOP_SECRET_KEYS/master_rsa').read())
    #TODO: what do these lines of code do?
    dsize = SHA.digest_size
    sentinel = Random.new().read(15+dsize)
    # Create the cypher object with the private key
    cipher = PKCS1_v1_5.new(key)
    # Decode encrypted data
    decoded_text = cipher.decrypt(f, sentinel)
    digest = SHA.new(decoded_text[:-dsize]).digest()
    if digest==decoded_text[-dsize:]:
        print(decoded_text)
    else:
        print("Bad encryption")
\end{python}
\end{center}


\section{Integrity}

\emph{TODO}: How do you ensure the botnet updates signed by the botnet master cannot be forged or modifed?

\section{Breaking into Skynet}
\emph{If SkyNet's botnet code is dismantled and/or the source code for it stolen, does your scheme become less secure?}
If one of the bots were to be infiltrated, the attacker would not have access to any of the master's private data, since the bots only possess the master's public key. Thus, it would not give the attacker any means to disrupt the rest of the network, since they still cannot sign messages. They also cannot access any of the data uploaded by the other bots, since that also requires the private key. However they would have control over that particular bot, and could use it for their own means. Potentially they could use the public key to create fake information that will be still accepted by the master, giving them other means to attack. 

\emph{Give an indication of how dismantledcult it would be for an adversary to take control of SkyNet when your protections are used.}

It would be very difficult for an adversary to take control of Skynet. Each individual bot is not particularly secure, however it is the botnet master that actually controls and has access to valuable information.
An infiltrated bot by itself would only be able to add to the valuables owned by the botnet by uploading encrypted data it discovers. It would not be able to obtain valuables mined by any other bot, since each bot encrypts it with the master's public key before uploading. Since the encrypted files require the botnet master's private key to decrypt, the infected bot would not be able to infiltrate further or gather useful information.
So the aim of the infiltrator would be to  take control of the botnet master. And this would be difficult, since there is no indication of which bot is actually the master in a huge peer to peer networkSo the problem of infiltration is reduced to the problem of obtaining the botnet master's private key. Thus it is very important for the botnet master to keep the private key in a secret place away from the reach of any bot and possibly encrypted using a password.


\end{document}
